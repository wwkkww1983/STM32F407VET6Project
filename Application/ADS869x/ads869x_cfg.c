#include "ads869x_cfg.h"

//===全局变量定义
ADS869X_HandlerType   g_ADS869XDevice0 = { 0 };
pADS869X_HandlerType  pADS869XDevice0 = &g_ADS869XDevice0;

//===统一发送字节命令
UINT8_T(*ADS869X_SPI_SEND_CMD)(ADS869X_HandlerType *, UINT8_T, UINT8_T *);
//===统一发送数组命令
UINT8_T(*ADS869X_SPI_SEND_ARRAY)(ADS869X_HandlerType*, UINT8_T*, UINT8_T*,UINT16_T);

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void ADS869X_SPI_Device0_Init(ADS869X_HandlerType *ADS869xx)
{

	//---复位信号
	ADS869xx->msgHWRST.msgGPIOPort = NULL;
	ADS869xx->msgHWRST.msgGPIOBit = LL_GPIO_PIN_0;

	//---GPIO时钟使能
	if (ADS869xx->msgHWRST.msgGPIOPort != NULL)
	{
		GPIOTask_Clock(ADS869xx->msgHWRST.msgGPIOPort, 1);
	}

	//---SPI1接口
	//---PA4------ > SPI1_NSS
	//---PA5------ > SPI1_SCK
	//---PA6------ > SPI1_MISO
	//---PA7------ > SPI1_MOSI
	
	//---SPI2接口
	//---PB12------ > SPI2_NSS
	//---PB13------ > SPI2_SCK
	//---PB14------ > SPI2_MISO
	//---PB15------ > SPI2_MOSI

	//---CS
	ADS869xx->msgSPI.msgCS.msgGPIOPort = GPIOB;				//GPIOA;
	ADS869xx->msgSPI.msgCS.msgGPIOBit  = LL_GPIO_PIN_12;	//LL_GPIO_PIN_4;

	//---SCK
	ADS869xx->msgSPI.msgSCK.msgGPIOPort = GPIOB;			//GPIOA;
	ADS869xx->msgSPI.msgSCK.msgGPIOBit = LL_GPIO_PIN_13;	//LL_GPIO_PIN_5;

	//---MISO  SD0
	ADS869xx->msgSPI.msgMISO.msgGPIOPort = GPIOB;			//GPIOA;
	ADS869xx->msgSPI.msgMISO.msgGPIOBit  = LL_GPIO_PIN_14;	//LL_GPIO_PIN_6;

	//---MOSI SDI
	ADS869xx->msgSPI.msgMOSI.msgGPIOPort = GPIOB;			//GPIOA;
	ADS869xx->msgSPI.msgMOSI.msgGPIOBit  = LL_GPIO_PIN_15;	//LL_GPIO_PIN_7;

	//---GPIO的配置
	LL_GPIO_InitTypeDef GPIO_InitStruct = { 0 };

	//---GPIO的初始化
	GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;					//---配置状态为输出模式
	GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;		//---GPIO的速度
	GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;		//---输出模式---推挽输出
	GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;						//---上拉使能

	//---初始化RST
	if (ADS869xx->msgHWRST.msgGPIOPort != NULL)
	{
		GPIO_InitStruct.Pin = ADS869xx->msgHWRST.msgGPIOBit;
		GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
		LL_GPIO_Init(ADS869xx->msgHWRST.msgGPIOPort, &GPIO_InitStruct);
		GPIO_OUT_1(ADS869xx->msgHWRST.msgGPIOPort, ADS869xx->msgHWRST.msgGPIOBit);
	}

	//---复用模式
	#ifndef USE_MCU_STM32F1
		//---端口复用模式
		ADS869xx->msgSPI.msgGPIOAlternate = LL_GPIO_AF_5;
	#endif
	//---SPI序号
		ADS869xx->msgSPI.msgSPIx = SPI2;//SPI1;
	#ifndef USE_MCU_STM32F1
		//---SPI的协议
		ADS869xx->msgSPI.msgStandard = LL_SPI_PROTOCOL_MOTOROLA;
	#endif

	UINT8_T i = 0;
	//---参考电压配置
	ADS869xx->msgREFPowerUV = ADS869X_REF_POWER_UV;
	for (i = 0; i < ADS869X_CHANNEL_MAX; i++)
	{
		ADS869xx->msgChannelRange[i] = 0;
		ADS869xx->msgIsPositive[i] = 0;
		ADS869xx->msgChannelNowADCResult[i] = 0;
		ADS869xx->msgChannelOldADCResult[i] = 0;
		ADS869xx->msgChannelPowerResult[i] = 0;
		ADS869X_SPI_ChannelRange(ADS869xx, i);
	}
	ADS869xx->msgDeviceReady = 0;
	ADS869xx->msgInitRetryCount = 3;
	ADS869xx->msgChipID = 0;
	//---默认配置特性
	ADS869xx->msgFeature = 0x28;
	//---默认是0xFF
	ADS869xx->msgAutoSeqEn = 0xFF;
	//---定义脉冲宽度
	ADS869xx->msgSPI.msgPluseWidth = 2;
	//---时钟空闲为低电平
	ADS869xx->msgSPI.msgCPOL = 0;
	//---数据采样在第二个时钟边沿
	ADS869xx->msgSPI.msgCPOH = 1;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void ADS869X_SPI_Device1_Init(ADS869X_HandlerType *ADS869xx)
{
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void ADS869X_SPI_Device2_Init(ADS869X_HandlerType *ADS869xx)
{
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_HW_Init(ADS869X_HandlerType *ADS869xx)
{
	//---注销当前的所有配置
	SPITask_DeInit(&(ADS869xx->msgSPI));
	//---硬件端口的配置---硬件实现
	SPITask_MHW_GPIO_Init(&(ADS869xx->msgSPI));
	//---硬件SPI的初始化
	LL_SPI_InitTypeDef SPI_InitStruct = {0};
	//---SPI的模式配置
	SPI_InitStruct.TransferDirection = LL_SPI_FULL_DUPLEX;
	SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;						//---主机模式
	SPI_InitStruct.DataWidth = LL_SPI_DATAWIDTH_8BIT;				//---8位数据
	//---时钟极性的设置
	if (ADS869xx->msgSPI.msgCPOL == 0)
	{
		//---CLK空闲时为低电平 (CLK空闲是只能是低电平)
		SPI_InitStruct.ClockPolarity = LL_SPI_POLARITY_LOW;
		GPIO_OUT_0(ADS869xx->msgSPI.msgSCK.msgGPIOPort, ADS869xx->msgSPI.msgSCK.msgGPIOBit);
	}
	else
	{
		//---CLK空闲时为高电平 (CLK空闲是只能是低电平)
		SPI_InitStruct.ClockPolarity = LL_SPI_POLARITY_HIGH;
	}
	//---数据采样的时钟边沿位置
	if (ADS869xx->msgSPI.msgCPOH ==0)
	{
		SPI_InitStruct.ClockPhase = LL_SPI_PHASE_1EDGE;
	}
	else
	{
		SPI_InitStruct.ClockPhase = LL_SPI_PHASE_2EDGE;
	}
	SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;							//---软件控制
	SPI_InitStruct.BaudRate = LL_SPI_BAUDRATEPRESCALER_DIV2;		//---系统时钟2分频
	SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;						//---高位在前
	SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;	//---硬件CRC不使能
	SPI_InitStruct.CRCPoly = 7;
	//---初始化查询方式的SPI
	SPITask_MHW_PollMode_Init(&(ADS869xx->msgSPI), SPI_InitStruct);
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_SW_Init(ADS869X_HandlerType *ADS869xx)
{
	SPITask_DeInit(&(ADS869xx->msgSPI));

	//---硬件端口的配置---软件实现
	SPITask_MSW_GPIO_Init(&(ADS869xx->msgSPI));

	//---时钟线的极性
	if (ADS869xx->msgSPI.msgCPOL == 0)
	{
		GPIO_OUT_0(ADS869xx->msgSPI.msgSCK.msgGPIOPort, ADS869xx->msgSPI.msgSCK.msgGPIOBit);
	}
	else
	{
		GPIO_OUT_1(ADS869xx->msgSPI.msgSCK.msgGPIOPort, ADS869xx->msgSPI.msgSCK.msgGPIOBit);
	}

	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：发送字节命令
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_SW_SendCmd(ADS869X_HandlerType *ADS869xx, UINT8_T cmd, UINT8_T *pRVal)
{
	//---数据发送
	return SPITask_MSW_WriteAndReadByteMSB(&(ADS869xx->msgSPI), cmd, pRVal);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：发送数组命令
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_SW_SendArray(ADS869X_HandlerType* ADS869xx, UINT8_T* pWVal, UINT8_T* pRVal, UINT16_T length)
{
	//---数据发送
	return SPITask_MSW_WriteAndReadDataMSB(&(ADS869xx->msgSPI), pWVal, pRVal, length);
}
///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：发送字节命令
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_HW_SendCmd(ADS869X_HandlerType *ADS869xx, UINT8_T cmd, UINT8_T *pRVal)
{
	//---数据发送
	return SPITask_MHW_PollMode_WriteAndReadByte(&(ADS869xx->msgSPI), cmd, pRVal);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：发送数组命令
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_HW_SendArray(ADS869X_HandlerType* ADS869xx, UINT8_T *pWVal, UINT8_T* pRVal,UINT16_T length)
{
	//---数据发送
	return SPITask_MHW_PollMode_WriteAndReadData(&(ADS869xx->msgSPI), pWVal, pRVal,length);
}
///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_Init(ADS869X_HandlerType *ADS869xx, void(*pFuncDelayus)(UINT32_T delay), void(*pFuncDelayms)(UINT32_T delay), UINT32_T(*pFuncTimerTick)(void), UINT8_T isHW)
{
	//---使用的DHT11的端口
	if ((ADS869xx != NULL) && (ADS869xx == ADS869X_TASK_ONE))
	{
		ADS869X_SPI_Device0_Init(ADS869xx);
	}
	else if ((ADS869xx != NULL) && (ADS869xx == ADS869X_TASK_TWO))
	{
		ADS869X_SPI_Device1_Init(ADS869xx);
	}
	else if ((ADS869xx != NULL) && (ADS869xx == ADS869X_TASK_THREE))
	{
		ADS869X_SPI_Device2_Init(ADS869xx);
	}
	else
	{
		return ERROR_1;
	}

	//---判断初始化的方式
	if (isHW != 0)
	{
		ADS869xx->msgSPI.msgModelIsHW = 1;
		ADS869X_SPI_HW_Init(ADS869xx);
		ADS869X_SPI_SEND_CMD = ADS869X_SPI_HW_SendCmd;
		ADS869X_SPI_SEND_ARRAY = ADS869X_SPI_HW_SendArray;
	}
	else
	{
		ADS869xx->msgSPI.msgModelIsHW = 0;
		ADS869X_SPI_SW_Init(ADS869xx);
		ADS869X_SPI_SEND_CMD = ADS869X_SPI_SW_SendCmd;
		ADS869X_SPI_SEND_ARRAY = ADS869X_SPI_SW_SendArray;
	}

	//---注册ms延时时间
	if (pFuncDelayms != NULL)
	{
		ADS869xx->msgFuncDelayms = pFuncDelayms;
	}
	else
	{
		ADS869xx->msgFuncDelayms = DelayTask_ms;
	}

	//---注册us延时函数
	if (pFuncDelayus != NULL)
	{
		ADS869xx->msgSPI.msgFuncDelayus = pFuncDelayus;
	}
	else
	{
		ADS869xx->msgSPI.msgFuncDelayus = DelayTask_us;
	}

	//---注册滴答函数
	ADS869xx->msgSPI.msgFuncTimeTick = pFuncTimerTick;

	//---配置ADS869X
	return ADS869X_SPI_ConfigInit(ADS869xx);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：写ADS869X命令寄存器
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteCommandReg(ADS869X_HandlerType *ADS869xx, UINT32_T cmd)
{
	UINT8_T _return = OK_0;
	UINT8_T wTemp[2] = { 0 };
	wTemp[0] = (UINT8_T)((cmd >> 8)&0xFF);
	wTemp[1] = (UINT8_T)(cmd & 0xFF);
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_0(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	_return = ADS869X_SPI_SEND_ARRAY(ADS869xx, wTemp, NULL, 2);
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_1(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：Program Register写操作
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteProgramReg(ADS869X_HandlerType *ADS869xx, UINT8_T addr, UINT8_T val)
{
	UINT8_T _return = OK_0;
	UINT8_T wTemp[2] = { 0 };
	wTemp[0] = (addr << 1) | 0x01;
	wTemp[1] = val;
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_0(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	_return = ADS869X_SPI_SEND_ARRAY(ADS869xx, wTemp, NULL, 2);
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_1(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：Program Register读操作
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadProgramReg(ADS869X_HandlerType *ADS869xx, UINT8_T addr, UINT8_T *pVal)
{
	UINT8_T _return = OK_0;
	UINT8_T wTemp[3] = { 0 };
	UINT8_T rTemp[3] = { 0 };
	wTemp[0] = (addr << 1) & 0xFE;
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_0(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	_return = ADS869X_SPI_SEND_ARRAY(ADS869xx, wTemp, rTemp, 3);
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_1(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}

	//---数据拷贝
	pVal[0] = rTemp[1];
	pVal[1] = rTemp[2];

	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：读命令返回
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadCommandBack(ADS869X_HandlerType* ADS869xx, UINT8_T* pVal)
{
	return ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_CMD_READ_BACK, pVal);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：继续工作在选中的状态
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_NO_OP(ADS869X_HandlerType* ADS869xx)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, ADS869X_CMD_REG_NO_OP);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_STDBY(ADS869X_HandlerType* ADS869xx)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, ADS869X_CMD_REG_STDBY);
}


///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：
//////输入参数:
//////输出参数:
//////说		明：退出此模式需执行AUTO_RST或者MAN_CH_n命令，且需要等待至少20us以保证正常数据的AD转换
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_PWRDN(ADS869X_HandlerType* ADS869xx)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, ADS869X_CMD_REG_PWR_DN);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：硬件复位设备
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T  ADS869X_SPI_HardReset(ADS869X_HandlerType *ADS869xx)
{
	if (ADS869xx->msgHWRST.msgGPIOPort!=NULL)
	{
		GPIO_OUT_0(ADS869xx->msgHWRST.msgGPIOPort, ADS869xx->msgHWRST.msgGPIOBit);
		ADS869xx->msgFuncDelayms(1);
		GPIO_OUT_1(ADS869xx->msgHWRST.msgGPIOPort, ADS869xx->msgHWRST.msgGPIOBit);
		ADS869xx->msgFuncDelayms(1);
	}
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：软件复位设备
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T  ADS869X_SPI_SoftReset(ADS869X_HandlerType *ADS869xx)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, ADS869X_CMD_REG_RST);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：设备复位
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_Reset(ADS869X_HandlerType* ADS869xx)
{
	UINT8_T _return = OK_0;
	if (ADS869xx->msgHWRST.msgGPIOPort != NULL)
	{
		_return = ADS869X_SPI_HardReset(ADS869xx);
	}
	else
	{
		_return = ADS869X_SPI_SoftReset(ADS869xx);
	}
	ADS869xx->msgDeviceReady = 0;
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：进入自动扫描模式
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_AUTORST(ADS869X_HandlerType* ADS869xx)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, ADS869X_CMD_REG_AUTO_RST);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：设置手动扫描通道
//////输入参数:
//////输出参数:
//////说		明：退出此模式需执行AUTO_RST或者MAN_CH_n命令，且需要等待至少20us以保证正常数据的AD转换
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ManualChannel(ADS869X_HandlerType* ADS869xx,UINT16_T manualCHCmd)
{
	return ADS869X_SPI_WriteCommandReg(ADS869xx, manualCHCmd);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：设置设备ID
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteChipID(ADS869X_HandlerType* ADS869xx, UINT8_T devid)
{
	devid <<= 6;
	ADS869xx->msgChipID = (devid & 0xC0) | ADS869xx->msgFeature;
	return ADS869X_SPI_WriteProgramReg(ADS869xx, ADS869X_PROG_REG_FEATURE_SELECT, ADS869xx->msgChipID);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：读取设备ID
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadChipID(ADS869X_HandlerType* ADS869xx, UINT8_T *pDevID)
{
	UINT8_T _return= ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_PROG_REG_FEATURE_SELECT, pDevID);
	*pDevID &= 0xC0;
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：校验设备ID
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_CheckChipID(ADS869X_HandlerType* ADS869xx)
{
	UINT8_T tempChipID = 0x00;
	UINT8_T _return = OK_0;
	_return = ADS869X_SPI_ReadChipID(ADS869xx, &tempChipID);
	//---校验读取的ID信息
	if (tempChipID!=ADS869xx->msgChipID)
	{
		_return += ERROR_1;
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：探测设备是否存在
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_DetectionDevice(ADS869X_HandlerType* ADS869xx)
{
	UINT8_T tempAutoSeqEn[2] = { 0 };
	UINT8_T _return = OK_0;
	_return=ADS869X_SPI_ReadProgramReg(pADS869XDevice0, ADS869X_PROG_REG_AUTO_SEQ_EN, tempAutoSeqEn);
	//---校验结果是否正确
	if (tempAutoSeqEn[1]!=ADS869xx->msgAutoSeqEn)
	{
		_return += ERROR_1;
	}
	else
	{
		//---校验设备的ID信息
		_return = ADS869X_SPI_CheckChipID(ADS869xx);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置自动扫描序列通道
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteAUTOSEQEN(ADS869X_HandlerType* ADS869xx, UINT8_T seq)
{
	ADS869xx->msgAutoSeqEn = seq;
	return ADS869X_SPI_WriteProgramReg(ADS869xx, ADS869X_PROG_REG_AUTO_SEQ_EN, seq);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：读取自动扫描序列通道
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadAUTOSEQEN(ADS869X_HandlerType* ADS869xx, UINT8_T *pAutoSeqEn)
{
	UINT8_T tempAutoSeqEn[2] = { 0 };
	UINT8_T _return= ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_PROG_REG_AUTO_SEQ_EN, tempAutoSeqEn);
	if (_return==OK_0)
	{
		if (tempAutoSeqEn[1]==ADS869xx->msgAutoSeqEn)
		{
			*pAutoSeqEn = tempAutoSeqEn[1];
		}
		else
		{
			_return = ERROR_2;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：通道掉电模式设置
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteChannelPWRDN(ADS869X_HandlerType* ADS869xx, UINT8_T ch)
{
	ADS869xx->msgChannelPWRDN = ch;
	return ADS869X_SPI_WriteProgramReg(ADS869xx, ADS869X_PROG_REG_CH_PWR_DN, ch);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：通道掉电模式读取
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadChannelPWRDN(ADS869X_HandlerType* ADS869xx, UINT8_T *pPWRDN)
{
	UINT8_T tempPWRDN[2] = { 0 };
	UINT8_T _return = ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_PROG_REG_CH_PWR_DN, tempPWRDN);
	if (_return == OK_0)
	{
		if (tempPWRDN[1] == ADS869xx->msgChannelPWRDN)
		{
			*pPWRDN = tempPWRDN[1];
		}
		else
		{
			_return = ERROR_2;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：通道掉电模式设置
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteFeature(ADS869X_HandlerType* ADS869xx, UINT8_T feature)
{
	ADS869xx->msgFeature = (feature&0x3F)|ADS869xx->msgChipID;
	return ADS869X_SPI_WriteProgramReg(ADS869xx, ADS869X_PROG_REG_FEATURE_SELECT, feature);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：通道掉电模式读取
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadFeature(ADS869X_HandlerType* ADS869xx, UINT8_T *pFeature)
{
	UINT8_T tempFeature[2] = { 0 };
	UINT8_T _return = ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_PROG_REG_FEATURE_SELECT, tempFeature);
	if (_return == OK_0)
	{
		if (tempFeature[1] == ADS869xx->msgFeature)
		{
			*pFeature = tempFeature[1];
		}
		else
		{
			_return = ERROR_2;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置通道的量程范围
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteChannelRange(ADS869X_HandlerType* ADS869xx, UINT8_T chReg, UINT8_T range)
{
	UINT8_T ch = ADS869X_CHANNEL_MAX;
	switch (chReg)
	{
		case ADS869X_PROG_REG_CH0_SET_RANGE:
			ADS869xx->msgChannelRange[0] = range;
			ch = 0;
			break;
		case ADS869X_PROG_REG_CH1_SET_RANGE:
			ADS869xx->msgChannelRange[1] = range;
			ch = 1;
			break;
		case ADS869X_PROG_REG_CH2_SET_RANGE:
			ADS869xx->msgChannelRange[2] = range;
			ch = 2;
			break;
		case ADS869X_PROG_REG_CH3_SET_RANGE:
			ADS869xx->msgChannelRange[3] = range;
			ch = 3;
			break;
		case ADS869X_PROG_REG_CH4_SET_RANGE:
			ADS869xx->msgChannelRange[4] = range;
			ch = 4;
			break;
		case ADS869X_PROG_REG_CH5_SET_RANGE:
			ADS869xx->msgChannelRange[5] = range;
			ch = 5;
			break;
		case ADS869X_PROG_REG_CH6_SET_RANGE:
			ADS869xx->msgChannelRange[6] = range;
			ch = 6;
			break;
		case ADS869X_PROG_REG_CH7_SET_RANGE:
			ADS869xx->msgChannelRange[7] = range;
			ch = 7;
			break;
		default:
			return ERROR_1;
	}

	//---每个通道的量程的配置
	ADS869X_SPI_ChannelRange(ADS869xx, ch);
	//---设置通道的量程
	return ADS869X_SPI_WriteProgramReg(ADS869xx, chReg, range);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置通道的量程范围
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ReadChannelRange(ADS869X_HandlerType* ADS869xx, UINT8_T chReg, UINT8_T *pRange)
{
	UINT8_T ch = ADS869X_CHANNEL_MAX;
	UINT8_T tempChannelRange[2] = { 0 };
	UINT8_T _return = OK_0;
	switch (chReg)
	{
		case ADS869X_PROG_REG_CH0_SET_RANGE:
			ch = 0;
			break;
		case ADS869X_PROG_REG_CH1_SET_RANGE:
			ch = 1;
			break;
		case ADS869X_PROG_REG_CH2_SET_RANGE:
			ch = 2;
			break;
		case ADS869X_PROG_REG_CH3_SET_RANGE:
			ch = 3;
			break;
		case ADS869X_PROG_REG_CH4_SET_RANGE:
			ch = 4;
			break;
		case ADS869X_PROG_REG_CH5_SET_RANGE:
			ch = 5;
			break;
		case ADS869X_PROG_REG_CH6_SET_RANGE:
			ch = 6;
			break;
		case ADS869X_PROG_REG_CH7_SET_RANGE:
			ch = 7;
			break;
		default:
			return ERROR_1;
	}
	//---读取通道的量程
	_return=ADS869X_SPI_ReadProgramReg(ADS869xx, chReg, tempChannelRange);
	//---判断读取结果
	if (_return == OK_0)
	{
		if (tempChannelRange[1] == ADS869xx->msgChannelRange[ch])
		{
			*pRange = tempChannelRange[1];
		}
		else
		{
			_return = ERROR_2;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置参考电压uv
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteREFPowerUV(ADS869X_HandlerType* ADS869xx, UINT32_T refUV)
{
	ADS869xx->msgREFPowerUV = refUV;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：读取参考电压
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT32_T ADS869X_SPI_ReadREFPowerUV(ADS869X_HandlerType* ADS869xx, UINT32_T refUV)
{
	return ADS869xx->msgREFPowerUV;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置参考电压mv
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_WriteREFPowerMV(ADS869X_HandlerType* ADS869xx, UINT32_T refMV)
{
	ADS869xx->msgREFPowerUV = refMV*1000;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：设置每通道的量程和量程最大值
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ChannelRange(ADS869X_HandlerType* ADS869xx, UINT8_T chIndex)
{
	UINT8_T _return = OK_0;
	if (chIndex==ADS869X_CHANNEL_MAX)
	{
		_return = ERROR_1;
	}
	else
	{
		switch (ADS869xx->msgChannelRange[chIndex])
		{
			//---正负1.25倍的VREF
			case ADS869X_RANGE_5120MV_5120MV:
				ADS869xx->msgChannelRangeIsPositive[chIndex] = 0;
				ADS869xx->msgChannelRangeFullUVX1000[chIndex] = ((UINT64_T)ADS869xx->msgREFPowerUV * 1250);//5120000000;
				ADS869xx->msgChannelRangeBaseUVX1000[chIndex] = (ADS869xx->msgChannelRangeFullUVX1000[chIndex] * 2) / (1<< ADS869X_ADC_SAMPLE_BITS); //39.0625;
				break;
			//---正负0.625倍的VREF
			case ADS869X_RANGE_2560MV_2560MV:
				ADS869xx->msgChannelRangeIsPositive[chIndex] = 0;
				ADS869xx->msgChannelRangeFullUVX1000[chIndex] = ((UINT64_T)ADS869xx->msgREFPowerUV * 625); //2560000000;
				ADS869xx->msgChannelRangeBaseUVX1000[chIndex] = (ADS869xx->msgChannelRangeFullUVX1000[chIndex] * 2) / (1 << ADS869X_ADC_SAMPLE_BITS); //19.53125;
				break;
			//---正2.5倍的VREF
			case ADS869X_RANGE_0MV_10240MV:
				ADS869xx->msgChannelRangeIsPositive[chIndex] = 1;
				ADS869xx->msgChannelRangeFullUVX1000[chIndex] = ((UINT64_T)ADS869xx->msgREFPowerUV * 2500);//10240000000;
				ADS869xx->msgChannelRangeBaseUVX1000[chIndex] = ADS869xx->msgChannelRangeFullUVX1000[chIndex] / (1 << ADS869X_ADC_SAMPLE_BITS); //39.0625;
				break;
			//---正1.25倍的VREF
			case ADS869X_RANGE_0MV_5120MV:
				ADS869xx->msgChannelRangeIsPositive[chIndex] = 1;
				ADS869xx->msgChannelRangeFullUVX1000[chIndex] = ((UINT64_T)ADS869xx->msgREFPowerUV* 1250);//5120000000;
				ADS869xx->msgChannelRangeBaseUVX1000[chIndex] = ADS869xx->msgChannelRangeFullUVX1000[chIndex] / (1 << ADS869X_ADC_SAMPLE_BITS); //19.53125;
				break;
			//---正负2.5倍的VREF
			case ADS869X_RANGE_10240MV_10240MV:
			default:
				ADS869xx->msgChannelRangeIsPositive[chIndex] = 0;
				ADS869xx->msgChannelRangeFullUVX1000[chIndex] = ((UINT64_T)ADS869xx->msgREFPowerUV * 2500);//10240000000;
				ADS869xx->msgChannelRangeBaseUVX1000[chIndex] = (ADS869xx->msgChannelRangeFullUVX1000[chIndex] * 2) / (1 << ADS869X_ADC_SAMPLE_BITS); //78.125
				break;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：通过ADC的采集结果计算ADC通道的电压值
//////输入参数：
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_CalcChannelPower(ADS869X_HandlerType* ADS869xx, UINT8_T chIndex,UINT8_T isCalcDelta)
{
	//---设置无数据
	ADS869xx->msgIsPositive[chIndex] = 0;
	UINT32_T adcDelta = 0;
	UINT64_T calcPower = 0;
	//---判断是否需要计算差值
	if (isCalcDelta != 0)
	{
		//---获取上次和本次的采样结果的绝对差值
		adcDelta = ABS_SUB(ADS869xx->msgChannelNowADCResult[chIndex], ADS869xx->msgChannelOldADCResult[chIndex]);
		//---软件数据补偿拟合开始
		if (adcDelta < 15)
		{
			if (adcDelta>5)
			{
				ADS869xx->msgChannelOldADCResult[chIndex] = MAX(ADS869xx->msgChannelNowADCResult[chIndex], ADS869xx->msgChannelOldADCResult[chIndex])-2;
			}
			else if (ADS869xx->msgChannelNowADCResult[chIndex] > ADS869xx->msgChannelOldADCResult[chIndex])
			{
				ADS869xx->msgChannelOldADCResult[chIndex] = ADS869xx->msgChannelNowADCResult[chIndex];
				if(adcDelta>2)
				{
					ADS869xx->msgChannelOldADCResult[chIndex] -=2;
				}
			}
			else if (ADS869xx->msgChannelNowADCResult[chIndex] < ADS869xx->msgChannelOldADCResult[chIndex])
			{
				ADS869xx->msgChannelOldADCResult[chIndex] -= 1;
			}
			else
			{
				ADS869xx->msgChannelOldADCResult[chIndex] = MAX(ADS869xx->msgChannelNowADCResult[chIndex], ADS869xx->msgChannelOldADCResult[chIndex]);
			}
			calcPower = ADS869xx->msgChannelOldADCResult[chIndex];
		}
		else
		{
			calcPower = ADS869xx->msgChannelNowADCResult[chIndex];
			ADS869xx->msgChannelOldADCResult[chIndex] = ADS869xx->msgChannelNowADCResult[chIndex];
		}
	}
	else
	{
		calcPower = ADS869xx->msgChannelNowADCResult[chIndex];
	}
	calcPower &= ((1<< ADS869X_ADC_SAMPLE_BITS)-1);
	//---软件数据补偿拟合结束
	//---将数字量转换为模拟量
	calcPower *= ADS869xx->msgChannelRangeBaseUVX1000[chIndex];
	double adcPower = 0;
	//---判断ADC采样的量程是双极性还是单极性
	if (ADS869xx->msgChannelRangeIsPositive[chIndex] == 0)
	{
		if ((ADS869xx->msgChannelNowADCResult[chIndex] & (1<< (ADS869X_ADC_SAMPLE_BITS-1))) != 0)
		{
			ADS869xx->msgIsPositive[chIndex] = 2;
			ADS869xx->msgChannelPowerResult[chIndex] = (UINT32_T)((calcPower - ADS869xx->msgChannelRangeFullUVX1000[chIndex]) / 1000);
		}
		else
		{
			ADS869xx->msgIsPositive[chIndex] = 1;
			ADS869xx->msgChannelPowerResult[chIndex] = (UINT32_T)((ADS869xx->msgChannelRangeFullUVX1000[chIndex] - calcPower) / 1000);
		}
	}
	else
	{
		ADS869xx->msgIsPositive[chIndex] = 2;
		ADS869xx->msgChannelPowerResult[chIndex] = (UINT32_T)(calcPower / 1000);
	}
	//---误差消除计算
	if (ADS869xx->msgADCKP[chIndex] != 0)
	{
		adcPower = ADS869xx->msgChannelPowerResult[chIndex];
		adcPower *= ADS869xx->msgADCKP[chIndex];
		if (adcPower< ADS869xx->msgADCDelta[chIndex])
		{
			ADS869xx->msgIsPositive[chIndex] = 1;
			adcPower = (ADS869xx->msgADCDelta[chIndex] - adcPower);
		}
		else
		{
			adcPower -= ADS869xx->msgADCDelta[chIndex];
		}
		ADS869xx->msgChannelPowerResult[chIndex] = (UINT32_T)adcPower;
	}
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：读取自动扫描通道序列的AD转换数据
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_GetAutoRSTResult(ADS869X_HandlerType *ADS869xx, UINT8_T chNum)
{
	UINT8_T i = 0;
	UINT8_T adcRTemp[5] = { 0 };
	UINT8_T adcWTemp[5] = { 0 };
	UINT8_T _return = 0;
	UINT8_T rstMode = ADS869xx->msgAutoSeqEn;
	//---判断设备是否初始化成功
	if (ADS869xx->msgDeviceReady == 1)
	{
		_return = ADS869X_SPI_ConfigInit(ADS869xx);
		if (_return != OK_0)
		{
			goto GoToExit;
		}
	}

	//---进入自动扫描模式
	_return =ADS869X_SPI_AUTORST(ADS869xx);

	//---扫描通道的结果
	for (i = 0; i < chNum; i++)
	{
		//---判断是否使能自动RST扫描功能
		if (rstMode & 0x01)
		{
			adcWTemp[3] = i;
			//---准备读取数据
			if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
			{
				GPIO_OUT_0(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
			}
			_return=ADS869X_SPI_SEND_ARRAY(ADS869xx, adcWTemp, adcRTemp, 5);
			//---结束数据的读取
			if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
			{
				GPIO_OUT_1(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
			}
			//---保存读取的数据
			ADS869xx->msgChannelNowADCResult[i] = adcRTemp[2];
			ADS869xx->msgChannelNowADCResult[i] = (ADS869xx->msgChannelNowADCResult[i] << 8) + adcRTemp[3];
			ADS869xx->msgChannelNowADCResult[i] = (ADS869xx->msgChannelNowADCResult[i] << 8) + adcRTemp[4];
			ADS869xx->msgChannelNowADCResult[i] >>= ADS869X_DATA_SAMPLE_BITS;
			//---计算采样结果
			ADS869X_SPI_CalcChannelPower(ADS869xx, i,0);
		}
		rstMode >>= 1;
	}
	GoToExit:
	return  _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_GetAutoRSTNSampleResult(ADS869X_HandlerType* ADS869xx, UINT8_T chNum)
{
	UINT8_T _return = OK_0;
	UINT8_T i = 0;
	UINT8_T j = 0;
	UINT8_T rstMode = ADS869xx->msgAutoSeqEn;
	//---保存采样结果
	UINT32_T adcSampleTemp[ADS869X_CHANNEL_MAX][ADS869X_N_SAMPLE_COUNT] = { 0 };
	//---获取采样结果
	for (i = 0; i < ADS869X_N_SAMPLE_COUNT; i++)
	{
		//---获取采样结果
		_return = ADS869X_SPI_GetAutoRSTResult(ADS869xx, chNum);
		//---采样数据搬移
		for (j=0;j< ADS869X_CHANNEL_MAX;j++)
		{
			adcSampleTemp[j][i] = ADS869xx->msgChannelNowADCResult[j];
		}
		//---校验数据
		if (_return != OK_0)
		{
			break;
		}
	}
	if (_return == OK_0)
	{
		//---采样数据搬移
		for (j = 0; j < ADS869X_CHANNEL_MAX; j++)
		{
			//---判断是否使能自动RST扫描功能
			if (rstMode & 0x01)
			{
				//---升序排列数据
				AscSortFun3(adcSampleTemp[j], ADS869X_N_SAMPLE_COUNT);
				//---计算均值
				ADS869xx->msgChannelNowADCResult[j] = CalcAvgFun5(adcSampleTemp[j], (ADS869X_N_SAMPLE_COUNT - 2), 2);
				//---计算采样的电压值
				ADS869X_SPI_CalcChannelPower(ADS869xx, j,1);
			}
			rstMode >>= 1;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：获取收到扫描通道的值
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T  ADS869X_SPI_GetManualChannelResult(ADS869X_HandlerType* ADS869xx, UINT16_T manualChannel)
{
	UINT8_T _return = OK_0;
	UINT8_T adcRTemp[5] = { 0 };
	UINT8_T adcWTemp[5] = { 0 };
	UINT8_T adcChannel = 0;
	//---判断设备是否初始化成功
	if (ADS869xx->msgDeviceReady==1)
	{
		_return=ADS869X_SPI_ConfigInit(ADS869xx);
		if (_return!=OK_0)
		{
			goto GoToExit;
		}
	}
	//---设置手动扫描通道
	_return = ADS869X_SPI_ManualChannel(ADS869xx, manualChannel);
	//---准备读取设置的扫描通道的值
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_0(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	//---读取ADC采样的结果
	_return = ADS869X_SPI_SEND_ARRAY(ADS869xx, adcWTemp, adcRTemp, 5);
	//---结束读取设置的扫描通道的值
	if (ADS869xx->msgSPI.msgCS.msgGPIOPort != NULL)
	{
		GPIO_OUT_1(ADS869xx->msgSPI.msgCS.msgGPIOPort, ADS869xx->msgSPI.msgCS.msgGPIOBit);
	}
	//---通道的转换
	adcChannel = (UINT8_T)(manualChannel >> 10) & 0x0F;
	//---判断是否是AUX通道配置
	if (adcChannel<8)
	{
		ADS869xx->msgChannelNowADCResult[adcChannel] = adcRTemp[2];
		ADS869xx->msgChannelNowADCResult[adcChannel] = (ADS869xx->msgChannelNowADCResult[adcChannel] << 8) + adcRTemp[3];
		ADS869xx->msgChannelNowADCResult[adcChannel] = (ADS869xx->msgChannelNowADCResult[adcChannel] << 8) + adcRTemp[4];
		ADS869xx->msgChannelNowADCResult[adcChannel] >>= ADS869X_DATA_SAMPLE_BITS;
		//---计算采样结果
		ADS869X_SPI_CalcChannelPower(ADS869xx, adcChannel,0);
	}
	GoToExit:
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：手动通道采样N次的测试结果
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_GetManualChannelNSampleResult(ADS869X_HandlerType* ADS869xx, UINT16_T manualChannel)
{
	UINT8_T _return = OK_0;
	UINT8_T i = 0;
	//---保存采样结果
	UINT32_T adcSampleTemp[ADS869X_N_SAMPLE_COUNT] = { 0 };
	//---获取ADC采样通道的序号
	UINT8_T adcChannelIndex = (UINT8_T)(manualChannel >> 10) & 0x0F;
	//---获取采样结果
	for ( i = 0; i < ADS869X_N_SAMPLE_COUNT; i++)
	{
		_return = ADS869X_SPI_GetManualChannelResult(ADS869xx, manualChannel);
		adcSampleTemp[i] = ADS869xx->msgChannelNowADCResult[adcChannelIndex];
		if (_return!=OK_0)
		{
			break;
		}
	}
	if (_return==OK_0)
	{
		//---升序排列数据
		AscSortFun3(adcSampleTemp, ADS869X_N_SAMPLE_COUNT);
		//---计算均值
		ADS869xx->msgChannelNowADCResult[adcChannelIndex] = CalcAvgFun5(adcSampleTemp, (ADS869X_N_SAMPLE_COUNT - 4), 4);
		//---计算采样的电压值
		ADS869X_SPI_CalcChannelPower(ADS869xx, adcChannelIndex,1);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：校准通道的误差
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_CalibrationChannelErr(ADS869X_HandlerType* ADS869xx)
{
	UINT8_T i = 0;
	UINT8_T rstMode = ADS869xx->msgAutoSeqEn;
	for (i = 0; i < ADS869X_CHANNEL_MAX; i++)
	{
		if ((rstMode&0x01)==0)
		{
			if (i==0)
			{
				////---1号板参数
				//ADS869xx->msgADCKP[i] = 1.013216;
				//ADS869xx->msgADCDelta[i] = 27130;

				//---2号板参数
				ADS869xx->msgADCKP[i] = 0;//1.013216;
				ADS869xx->msgADCDelta[i] = 26430;
			}
			else
			{
				////---1号板参数
				//ADS869xx->msgADCKP[i] = 1.0129;
				//ADS869xx->msgADCDelta[i] = 25870;

				//---2号板参数
				ADS869xx->msgADCKP[i] = 0;//1.0129;
				ADS869xx->msgADCDelta[i] = 27070;
			}
			
		}
		rstMode >>= 1;
	}
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功	    能：初始化配置
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
UINT8_T ADS869X_SPI_ConfigInit(ADS869X_HandlerType* ADS869xx)
{
	UINT8_T _return = OK_0;
	UINT8_T tempBuffer[3] = { 0 };
	UINT8_T i = 0;
	if (ADS869xx->msgInitRetryCount==0)
	{
		ADS869xx->msgInitRetryCount = 1;
	}

	//---循环多次初始化设备
	for (i=0;i< ADS869xx->msgInitRetryCount;i++)
	{
		//---复位芯片
		_return = ADS869X_SPI_Reset(ADS869xx);
		//---校验
		if (_return == OK_0)
		{
			//---设备特征配置
			_return = ADS869X_SPI_WriteFeature(ADS869xx, 0x28);
			//---校验
			if (_return == OK_0)
			{
				//---读取设备的特征
				_return = ADS869X_SPI_ReadFeature(ADS869xx, tempBuffer);
				//---校验
				if (_return == OK_0)
				{
					break;
				}
			}
		}
	}

	//---设置扫描方式
	_return = ADS869X_SPI_WriteAUTOSEQEN(ADS869xx, 0xF0);
	//---读取设置的值
	_return = ADS869X_SPI_ReadProgramReg(ADS869xx, ADS869X_PROG_REG_AUTO_SEQ_EN, tempBuffer);

	//---判断校验
	if (ADS869xx->msgAutoSeqEn != tempBuffer[1])
	{
		_return = ERROR_1;
		ADS869xx->msgDeviceReady = 1;
	}
	else
	{
		//---设置通道的量程
		ADS869X_SPI_WriteChannelRange(ADS869xx, ADS869X_PROG_REG_CH0_SET_RANGE, ADS869X_RANGE_0MV_5120MV);
		ADS869X_SPI_WriteChannelRange(ADS869xx, ADS869X_PROG_REG_CH1_SET_RANGE, ADS869X_RANGE_0MV_5120MV);
		ADS869X_SPI_WriteChannelRange(ADS869xx, ADS869X_PROG_REG_CH2_SET_RANGE, ADS869X_RANGE_0MV_5120MV);
		//---设置工作模式
		ADS869X_SPI_AUTORST(ADS869xx);
	}
	ADS869X_SPI_CalibrationChannelErr(ADS869xx);
	return _return;
}